# Nivtropy — исправление проблем после правок Codex (общие точки / системы / Z0)

Этот документ — **новая инструкция**, почему сейчас UI ведёт себя неправильно (служебные строки как “общие точки”, пустые системы, отсутствие Z0 у смежных ходов) и **что именно нужно изменить**, чтобы решалась задача по сути, а не “чтобы просто собиралось”.

---

## 0) Что сейчас сломано и почему

### 0.1 Общие точки: в список попадают `Start-Line/End-Line` и прочие служебные строки
Источник: `Presentation/ViewModels/NetworkViewModel.cs`, метод `BuildSharedPointUsage(...)`.

Проблема:
- В расчёте общих точек **не фильтруются** записи с `LineMarker != null`.
- В код точки берётся `Target ?? StationCode` — а для формата `For M5` в служебных строках `Target` содержит `BF ...`, что и попадает в UI как “общая точка”.

Ожидаемое:
- Общие точки определяются **только по реальным точкам нивелирования** (точки, через которые проходят **минимум два разных хода**).
- Служебные строки **никогда** не могут считаться точками сети.

---

### 0.2 “Системы” пустые, а список систем показывает (0)
Источник: `Presentation/ViewModels/NetworkViewModel.cs` и `Presentation/Views/SystemsManagementWindow.xaml(.cs)`.

Проблема:
- `NetworkViewModel` создаёт `_systems` с системой “Основная”, но **не заполняет** `RunIndexes`.
- А у `LineSummary.SystemId` после импорта часто `null`, поэтому `SystemsManagementWindow` не находит ходы:  
  `Runs.Where(r => r.SystemId == selectedSystem.Id)` → пусто.

Ожидаемое:
- После импорта каждый `LineSummary` должен иметь `SystemId` (минимум `system-default`).
- Система должна иметь актуальный `RunCount`, т.е. `RunIndexes` должны быть синхронизированы.

---

### 0.3 Смежные ходы “не получают Z0” (неуравненную высоту)
Проблема в пайплайне расчёта: `CalculateHeightsHandler` считает **только один набор высот** (после поправок), а “сырой” Z0 нигде не считается/не сохраняется.

Ожидаемое:
- Z0 и Z должны быть различными сущностями:
  - **Z0** — высоты, полученные по `Δh = Rb - Rf` **без поправок**.
  - **Z** — высоты после локального/сетевого уравнивания (по `AdjustedΔh`).
- В таблице должны заполняться **оба** столбца там, где сеть связана с репером(ами).

---

### 0.4 Критический системный корень: перепутана семантика “код точки” vs “код станции/хода”
Источник: `Application/Commands/Handlers/BuildNetworkHandler.cs`, метод `BuildRunObservations(...)`.

Сейчас используется `record.StationCode` как “код точки” (BackCode/ForeCode).  
Но в парсерах:
- Для `TrimbleDiniParser` точка = `record.Target` (token[1]), а `StationCode` = номер хода (token[4]).
- Для `ForFormatParser` ситуация аналогичная: `StationCode` — не код точки.

Итог:
- Сеть строится по неверным вершинам → ломается связность, общие точки и перенос высот между ходами.

Ожидаемое:
- **Единый контракт** по всему коду:  
  **PointCode = `MeasurementRecord.Target`** (очищенный код точки),  
  `StationCode` — это “служебное” (номер станции / номер хода / то, что нужно для UI), но **не топология сети**.

---

## 1) Acceptance criteria (как понять, что стало правильно)

1) В “Общие точки между ходами” **никогда** не появляется `Start-Line`, `End-Line`, `Cont-Line`, `BF`, `FB` и прочая служебка.  
2) Если два хода реально имеют общую точку, в списке появляется **код этой точки**, и справа выводится `Ход 01, Ход 02, ...`.  
3) В “Системы ходов” система “Основная” показывает корректный счётчик `(N)`, а справа внутри системы видны ходы.  
4) В таблице ходов:
   - `Z0` заполняется там, где высоты могут быть распространены от репера(ов) **без поправок**.
   - `Z` заполняется после уравнивания, и при наличии невязки/замыканий значения могут отличаться от `Z0`.
5) При отключении общей точки (галочка), связь по этой точке в графе **разрывается**, и высоты через неё **не распространяются** (это видно и по графу, и по Z/Z0 в смежном ходе).

---

## 2) Конкретные правки по коду (обязательные)

### 2.1 Нормализовать “код точки” на уровне парсеров
**Цель:** чтобы `Domain.Model.MeasurementRecord.Target` был *только* кодом точки, без времени/служебных хвостов.

#### 2.1.1 `Infrastructure/Parsers/TrimbleDiniParser.cs`
- На `Start-Line` строке сейчас теряется `BF/FB`.  
  Нужно:
  - Парсить `BF|FB` и записывать в `record.Mode` (или завести отдельное поле типа `RunDirection` — но проще Mode для маркерных строк).
  - `OriginalLineNumber` уже есть — ок.

#### 2.1.2 `Infrastructure/Parsers/ForFormatParser.cs`
Сейчас для измерительных строк `Mode = KD1`, `Target` содержит мусор (например `1 13:11:041`).
Нужно привести:
- `Target = "<код точки>"` (в примере это `1`)
- `StationCode = "<номер хода>"` (в примере это `3`)
- `Mode` оставить для “KD1”/прочего (или отделить в будущем), но **не смешивать** с PointCode.

Рекомендуемая реализация:
- Внутри `ParseLine(...)` после извлечения сегмента (`modeSegment`) разобрать токены:
  - Первый токен → `Mode`
  - Второй токен → `Target` (PointCode)
  - Последний токен (если числовой) → `StationCode`
- Для маркерных строк (`Start-Line`, `End-Line`) ставить `LineMarker != null` и **не пытаться** наполнять `Target` “как точку”.

> Важно: если формат данных отличается — добавить unit-test по реальному файлу пользователя и подогнать именно под него.

---

### 2.2 Исправить построение сети: использовать `Target` как код точки и выкинуть маркеры
Файл: `Application/Commands/Handlers/BuildNetworkHandler.cs`

В `BuildRunObservations(...)` сделать:

1) **Сразу пропускать** записи с `record.LineMarker != null`.  
2) Для определения кода точки использовать:
   - `var pointCode = NormalizePointCode(record.Target);`
   - если `Target` пустой, можно fallback на `record.StationCode`, но это должно быть редким/явным исключением.
3) Убрать подмену `BackCode/ForeCode` через `StationCode`:
   - `pending.BackCode = pointCode;`
   - `pending.ForeCode = pointCode;`

Рекомендуемая функция нормализации:
```csharp
private static string? NormalizePointCode(string? raw)
{
    if (string.IsNullOrWhiteSpace(raw)) return null;
    var s = raw.Trim();
    // если в Target всё ещё встречаются хвосты, то хотя бы режем по пробелу:
    return s.Split(new[]{' ', '\t'}, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
}
```

> Это критично: иначе **вся** доменная сеть строится по неверным узлам, и дальше любые “общие точки/системы/высоты” будут мусором.

---

### 2.3 Починить список “общих точек” в UI (и прекратить считать их по сырому тексту)
Файл: `Presentation/ViewModels/NetworkViewModel.cs`

Сейчас `UpdateSharedPoints()` и `BuildSharedPointUsage()`:
- учитывают служебные строки,
- берут не тот “код точки”.

Нужно сделать одно из двух (лучше вариант A):

#### Вариант A (правильный): общие точки только из доменной сети
После того, как сеть построена (`BuildNetworkHandler`), определить общие точки так:
- `network.Points.Values.Where(p => p.IsSharedPoint)`
- код = `p.Code.ToString()`
- список ходов = `p.ConnectedRuns` → маппинг на `LineSummary` (по `OriginalLineNumber` или отдельному `SequenceIndex` — см. ниже)

И уже это выводить в `NetworkViewModel.SharedPoints`.

#### Вариант B (быстрый фикс): жёстко фильтровать `LineMarker` и нормализовать код
Если пока рано тянуть из домена:
- В `BuildSharedPointUsage` пропускать `record.LineMarker != null`
- код точки брать только из `record.Target` и пропускать то, что не похоже на код точки (например `Start-Line`, `End-Line`, `BF`, `FB`).

Но: вариант B будет ломаться на новых форматах. Вариант A устойчивый.

---

### 2.4 Заполнить системы и связать их с ходами (минимум: дефолт)
Файл: `Presentation/ViewModels/NetworkViewModel.cs`

Добавить метод `InitializeSystemsFromRuns()` и вызывать его:
- после импорта,
- после пересборки `Runs`,
- после любых операций перемещения ходов между системами.

Алгоритм:
1) Убедиться, что есть система `system-default`.
2) Очистить всем системам `RunIndexes`.
3) Для каждого `LineSummary`:
   - если `run.SystemId` пустой → `run.SystemId = "system-default"`
   - найти систему по `run.SystemId` и добавить `run.Index` в `RunIndexes`

Это сразу исправит:
- “Основная (0)” → станет “Основная (N)”
- в `SystemsManagementWindow` начнут появляться ходы.

> Дальше уже можно (в следующей итерации) делать “авто-системы” по связности сети через общие точки, но **сначала** нужно добиться корректной дефолтной инициализации.

---

### 2.5 Реализовать вычисление Z0 (сырой высоты) и показать её в таблице
Проблема: сейчас считается только Z (после поправок).

Решение:
- Сделать вычисление высот **двумя проходами**, без потери состояния.

#### Минимально-инвазивный путь (рекомендовано)
Добавить сервис (Domain или Application уровень), который **не мутирует** `Point.Height`, а возвращает снимок высот:
```csharp
Dictionary<Point, double> ComputeHeightsSnapshot(LevelingNetwork network, bool useCorrections)
```

- При `useCorrections=false` использовать `obs.DeltaH`
- При `useCorrections=true` использовать `obs.AdjustedDeltaH`

Далее:
1) В обработчике расчёта (или в Query на построение таблицы) получить:
   - `rawHeights = ComputeHeightsSnapshot(network, false)`
   - `adjustedHeights = ComputeHeightsSnapshot(network, true)` (или текущее состояние сети)
2) При формировании строк журнала (`StationDto`/`TraverseRow`):
   - `BackHeightRaw/ForeHeightRaw` заполнять из `rawHeights`
   - `BackHeight/ForeHeight` — из `adjustedHeights`

> Важно: Z0 должен считаться **по сети** (BFS от реперов), а не “внутри одного хода”, иначе смежные ходы не получат значения.

---

## 3) Где доменная архитектура “не дотянута” (и это влияет на баги)

На текущий момент DDD слой уже есть (LevelingNetwork/Run/Point/Observation), но UI всё ещё:
- считает общие точки сам (`NetworkViewModel.BuildSharedPointUsage`),
- держит системы сам (`NetworkViewModel._systems`) и не синхронизирует их с `Runs`,
- не имеет нормального “двухпроходного” расчёта высот (Z0+Z).

Это означает: **архитектура не завершена**, и поэтому появляются “рассинхроны” (UI показывает не то, что в домене).

Рекомендация:
- Сделать “источник правды” один:
  - топология сети + общие точки → из домена
  - принадлежность ходов системам → либо тоже домен, либо UI, но без дублей
  - высоты Z0/Z → из одного вычислительного пайплайна, а не случайных вычислений в разных местах

---

## 4) Быстрый чек-лист после правок

1) Импорт тестового файла (`TestData/251219.DAT`) → в “Системы ходов” **Основная (N)**.  
2) В “Общие точки между ходами” нет `Start-Line/End-Line`.  
3) Есть хотя бы одна реальная общая точка (по данным), и она показана корректно.  
4) Z0 заполнена для связной части сети от репера.  
5) При переключении “сетевое уравнивание” изменяются Z (если сеть содержит избыточность/замыкание), а Z0 остаётся прежней.

---

## 5) Что делать, если после фикса PointCode всё равно не находится
Это значит, что формат входных файлов отличается от `TestData/*`.

Тогда нужно:
- добавить 1–2 файла пользователя в `TestData/`
- написать unit-test на парсер, который проверяет:
  - для измерительных строк: `Target == "<код точки>"`
  - для маркерных строк: `LineMarker != null` и они **не попадают** в сеть/общие точки.

---

### Примечание
Этот документ **намеренно** не предлагает “закостылить, чтобы не падало”, а требует привести “код точки” и пайплайн высот в корректное состояние — иначе ни МНК, ни визуализация, ни синхронизация ходов не будут надёжными.
