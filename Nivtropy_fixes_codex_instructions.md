# Nivtropy — инструкция (Codex) по исправлениям
_Виртуальные станции / локальное уравнивание / округление / МНК сети / визуализация графов_

Эта инструкция предназначена для внесения **функциональных** исправлений в репозиторий `Nivtropy` (не “чтобы компилилось”, а чтобы **правильно считалось и рисовалось**).

---

## 0) Цели и критерии приёмки

### A. Полностью убрать виртуальные станции
**Нужно:** перестать создавать техническую строку “станция только с одной точкой” в начале каждого хода.

**Приёмка:**
- в журнале/таблице хода **нет** первой строки, где заполнена только одна точка (как на вашем скрине);
- расчёты невязок, поправок, статистик и экспорт не зависят от “виртуальности”;
- если стартовая точка имеет известную отметку — она корректно отображается и используется.

---

### B. Локальное уравнивание корректно для секций между известными точками
**Нужно:**
- считать невязку секции относительно **теоретической разности высот** между якорями (реперами);
- распределять поправки по длинам (или весам) и **после округления** сохранять суммарное замыкание.

**Приёмка:**
- если секция начинается/заканчивается известными отметками, после уравнивания рассчитанная высота в конце совпадает с известной (точность ~1e-9);
- округление поправок до 0.0001 м не ломает замыкание секции.

---

### C. Реализовать уравнивание сети по МНК (AdjustmentMode.Network)
**Нужно:** реализовать LS-решатель для высотной сети: узлы = точки, наблюдения = превышения.

**Приёмка:**
- `AdjustmentMode.Network` реально считает: отметки узлов, поправки наблюдений, остатки;
- “общие точки” объединяются в один узел (если не отключены пользователем).

---

### D. Визуализация ходов как графа
**Нужно:** рисовать **граф**: узлы (точки) + ребра (станции), а не “одна линия на ход”.

**Приёмка:**
- общие точки объединены в один узел;
- каждый ход рисуется как цепочка станций (polyline);
- известные точки выделены отдельно (иконка/форма), общие точки — отдельно.

---

## 1) Полное удаление виртуальных станций

### 1.1 Где они создаются и что делать
Файл: `Application/Services/TraverseCalculationService.cs`  
Метод: `BuildTraverseRowsInternal(...)`

В проекте есть логика вставки “виртуальной” записи в начало хода (станция с одной точкой и стартовой отметкой).  
**Требование:** удалить эту вставку полностью, и не заменять её новой “виртуальной” сущностью.

**Ожидаемое состояние после правки:**
- первая строка в `rows/stations` — это **первая реальная** измеренная станция (имеет BackCode и ForeCode и DeltaH);
- стартовая точка хода (BackCode первой станции) используется как “нулевая точка профиля” без отдельной строки.

> Если в модели/DTO есть `IsVirtualStation` — его можно оставить ради совместимости, но pipeline больше никогда не должен создавать `IsVirtualStation=true`.

---

### 1.2 Что ломается после удаления и как починить правильно

#### 1) Профиль (отрисовка)
Файл: `Presentation/Visualization/ProfileVisualizationService.cs`

Сейчас профиль/точки профиля, скорее всего, опираются на `IsVirtualStation` или на наличие отдельной “стартовой” строки.

**Нужно:** формировать профиль так:
- добавить **первую точку** (distance=0) из `rows.First().BackCode` / `rows.First().BackHeight`;
- затем для каждой реальной станции добавлять точку по `ForeCode/ForeHeight`, увеличивая расстояние на длину станции.

Псевдокод:
```csharp
var first = rows.First();
AddPoint(code: first.BackCode, dist: 0, height: first.BackHeight);

double dist = 0;
foreach (var r in rows.Where(x => x.DeltaH.HasValue))
{
    dist += r.StationLength_m ?? 0;
    AddPoint(code: r.ForeCode, dist: dist, height: r.ForeHeight);
}
```

#### 2) Статистика профиля
Файл: `Application/Services/ProfileStatisticsService.cs`

Если раньше StationCount и выбор высот зависели от виртуальной строки:
- считать `StationCount` = число реальных станций (`DeltaH.HasValue`);
- стартовая высота берётся из `BackHeight` первой реальной станции;
- далее — `ForeHeight` по станциям.

#### 3) Экспорт журнала
Файл: `Infrastructure/Export/TraverseExportService.cs` (или аналогичный)

Экспорт должен включать стартовую точку **без отдельной виртуальной строки**:
- либо первой строкой “StartPoint” (не Station),
- либо через формат “Back/Fore в одной строке”.

#### 4) StationsCount в статистике хода
Файл: `Application/Services/TraverseProcessingService.cs` (или где строится статистика)
- `StationsCount` = `rows.Count(r => r.DeltaH.HasValue)`.

---

### 1.3 UI-таблица: как отображать Z0/Z без виртуальной строки
В WPF таблице (например `TraverseJournalView.xaml`) раньше стартовая отметка попадала в виртуальную строку.

**Решение:** сделать колонки высот шаблонными:
- верхняя строка ячейки — `BackHeight`,
- нижняя — `ForeHeight`.

Это сохранит визуальный формат “Z0 / Z” и уберёт костыль виртуальной строки.

---

## 2) Локальное уравнивание (Local) + исправление округления

### 2.1 Главная логическая ошибка сейчас
Файл: `Domain/Services/TraverseCorrectionService.cs`

Текущее уравнивание часто считает невязку секции как:
- `sectionClosure = Σ(Δh) * sign`

**Это неверно** для секции между двумя известными точками.  
Правильно:

Пусть:
- `S = Σ Δh_i` (сумма измеренных превышений по секции)
- `T = H_end - H_start` (теоретическая разность по известным отметкам якорей)
- `sign = methodOrientationSign` (1 или -1, если сохраняете эту модель)

Тогда невязка секции:
- `f = sign * (S - T)`

А сумма поправок **к Δh** должна быть:
- `Σv_required = (T - S)`  
(потому что мы корректируем Δh так, чтобы сумма стала равна T)

Иными словами, после уравнивания:
- `Σ(Δh_i + v_i) = T`.

---

### 2.2 Изменить API сервиса поправок: нужны высоты якорей
Сейчас `TraverseCorrectionService` получает только `isAnchor(code)` — этого недостаточно.

**Нужно добавить:**
- `Func<string?, double?> getKnownHeightMeters`

Точка является “якорем” секции, если:
- `getKnownHeightMeters(code) != null`.

---

### 2.3 Правильный алгоритм для AdjustmentMode.Local

1) Собрать список точек хода в порядке прохождения:
- `P0 = rows[0].BackCode`
- `P1 = rows[0].ForeCode`
- …
- `Pn = rows[last].ForeCode`

2) Определить якоря (реперы/известные):
- `anchorIndices = индексы Pi, где getKnownHeightMeters(Pi) != null`

3) Разбить ход на секции между соседними якорями:
- секция = диапазон станций, покрывающий путь от anchor k до anchor k+1.

4) Для каждой секции:
- `Hstart = getKnownHeightMeters(anchorStart)`
- `Hend = getKnownHeightMeters(anchorEnd)`
- `T = Hend - Hstart`
- `S = Σ Δh` по станциям секции
- `Σv = T - S`

5) Распределить поправки по станциям секции:
- базово пропорционально длине: `v_i_raw = Σv * L_i / ΣL`
- где `L_i` — длина станции (определите единый смысл: либо avg плеч, либо сумма плеч, но последовательно).

6) **Округление поправок с сохранением суммы** (обязательно) — см. пункт 2.4.

7) Применить поправки:
- `Δh_adj = Δh + v_i_rounded`
- высоты протянуть заново внутри секции, чтобы end совпал с Hend.

---

### 2.4 Округление до 0.0001 м без потери замыкания
Проблема: если просто округлять каждую поправку `Math.Round(v, 4)`, сумма уезжает.

**Нужно:** округлять и затем распределять остаток кратно шагу.

Параметры:
- `step = 0.0001`

Алгоритм:
1) вычислить `v_i_raw`
2) округлить: `v_i = Round(v_i_raw, 4)`
3) `residual = Σv_required - Σ v_i`
4) перевести в тики: `ticks = round(residual / step)` (целое)
5) распределить эти тики по станциям (лучше по самым длинным), добавляя/убавляя `step`.

Псевдокод:
```csharp
double step = 0.0001;

var v = raw.Select(x => Math.Round(x, 4)).ToArray();
double residual = requiredSum - v.Sum();
int ticks = (int)Math.Round(residual / step);

var order = stations
    .Select((s, idx) => (idx, L: s.StationLength_m ?? 0))
    .OrderByDescending(x => x.L)
    .Select(x => x.idx)
    .ToArray();

int k = 0;
while (ticks != 0)
{
    int i = order[k % order.Length];
    v[i] += (ticks > 0 ? step : -step);
    ticks += (ticks > 0 ? -1 : 1);
    k++;
}
```

**Приёмка округления:**
- `Math.Abs(v.Sum() - Σv_required) <= 1e-12`
- при этом каждый `v_i` кратен 0.0001.

---

### 2.5 Тест-кейсы (минимум)
Добавить unit-тесты (или интеграционные тесты) на:
1) открытый ход между двумя известными отметками (2 якоря) — после Local уравнивания конец совпадает.
2) случай, где residual после округления не 0, и проверка докрутки.
3) случай с несколькими секциями (якорь внутри) — каждая секция закрывается на свой Hend.

---

## 3) Реализация МНК для сети (AdjustmentMode.Network)

### 3.1 Модель наблюдений для нивелирования
Для каждого измеренного превышения:
- наблюдение `l_k = Δh_k`
- уравнение: `H_to - H_from = l_k + v_k`
- веса обычно: `w_k = 1 / L_k` (L в км или м — главное последовательно).

**Задача МНК:** минимизировать `Σ (w_k * v_k^2)` при наличии фиксированных высот (реперов).

---

### 3.2 Требуемая архитектура (рекомендуемая)
Добавить новый сервис в Application или Domain (зависит от архитектуры проекта):

- `ILevelNetworkAdjustmentService`
  - Input:
    - список наблюдений `Observation { FromCode, ToCode, DeltaH, Length }`
    - известные отметки `Dictionary<string,double> knownHeights`
    - настройки веса/режима (1/L, 1/L^2, константный)
  - Output:
    - `Dictionary<string,double> adjustedHeights`
    - `Dictionary<int,double> observationCorrections` (по id наблюдения)
    - метрики качества (по желанию): sigma0, rms, etc.

---

### 3.3 Как строить уравнения (эффективно, без плотных матриц)
Матрица A разреженная: в каждой строке ровно 2 ненулевых:
- для неизвестных высот:
  - коэффициент для `H_from` = -1
  - коэффициент для `H_to` = +1

Стандартная форма:
- `A x ≈ b`
где `b = l_k` (наблюдения), `x` — неизвестные отметки.

Если часть узлов известна:
- исключить известные из x (фиксировать),
- перенести их в правую часть.

Для каждого наблюдения:
- если `from` известен: b += H_from
- если `to` известен: b -= H_to
- неизвестные коэффициенты остаются в A.

Далее нормальные уравнения:
- `N = Aᵀ P A`
- `u = Aᵀ P b`
- решаем `N x = u`.

**Примечание:** Если нет ни одной фиксированной высоты (free-net), система имеет дефект 1.
Решение:
- либо фиксировать один узел (выбрать опорный),
- либо добавить внутреннее условие (например сумма x = 0).
Для продукта обычно достаточно “фиксировать один узел” (самый надёжный репер или первый узел).

---

### 3.4 Интеграция с текущим пайплайном
Сейчас система обрабатывается “жадно” (ход за ходом), протягивая высоты.

Для `AdjustmentMode.Network` сделать другой путь:
1) собрать по **всей системе** наблюдения (все StationDto с Δh) в список Observation;
2) прогнать МНК;
3) записать в результаты:
   - поправки к Δh каждой станции,
   - вычисленные отметки узлов (BackHeight/ForeHeight) на основании `adjustedHeights`.

После этого:
- статистика и профиль строятся уже на уравнённых данных.

---

### 3.5 Что ожидается в результате (UI/вывод)
- для каждой станции доступны:
  - `Correction` (v_k)
  - `DeltaHAdjusted` или `DeltaH + Correction`
- для каждой точки:
  - `H_adjusted`
- для сети/системы:
  - суммарные невязки по контурам/ходам (по желанию)
  - качество (sigma0) — опционально, но желательно.

---

## 4) Визуализация: красивые графы ходов

### 4.1 Что должно быть на схеме
- Узлы: точки (известные/общие/обычные)
- Рёбра: станции (из наблюдений Δh)
- Ходы: группы рёбер (для подсветки/легенды)

### 4.2 Построение графа
Добавить builder:
- `LevelGraphBuilder`
  - Input: список StationDto/Observation + known heights + shared states
  - Output:
    - `Node { Id, Label, Type }`
    - `Edge { FromId, ToId, RunId, StationIndex, Length, DeltaH }`

**Объединение общих точек:**
- если точка shared и **не отключена** пользователем — один NodeId для всех упоминаний;
- если shared отключена (как сейчас делаете через суффикс `(runName)`), то узлы различать.

### 4.3 Layout (чтобы было “красиво”)
Рекомендуемый layout: force-directed (Fruchterman–Reingold) — легко реализуется и выглядит прилично.

Минимальные требования:
- поддержка zoom/pan;
- подписи на известных и “узловых” точках (degree > 2);
- подсветка выбранного хода;
- tooltip на ребре: Δh, L, номер станции.

### 4.4 Стили
- известные: треугольник/квадрат + жирная подпись
- общие: двойной круг
- обычные: точка
- ребра: тонкие, при выборе хода — толще/ярче

---

## 5) План работ по шагам (рекомендуемый порядок)

1) **Удалить виртуальные станции** в `TraverseCalculationService` и привести потребителей (профиль/экспорт/UI) к новой модели.
2) Починить **Local**:
   - новый API для известных высот,
   - секции между якорями,
   - округление с сохранением суммы.
3) Реализовать **Network (МНК)** как отдельный сервис, интегрировать в pipeline `AdjustmentMode.Network`.
4) Переписать визуализацию систем на **узлы+рёбра по станциям** и добавить layout.
5) Добавить тесты: virtual-stations=0, Local closes sections, rounding residual distribution, Network solves simple net.

---

## 6) Проверка регрессий (чеклист)

- [ ] Любой ход: первая строка содержит Back+Fore и Δh, нет “одиночной” станции.
- [ ] Local: если заданы 2 репера — секция закрывается.
- [ ] Округление: Σv ровно соответствует требуемому.
- [ ] Network: на простой сети (2 репера + 3 узла + несколько наблюдений) решение устойчивое и даёт ожидаемые отметки.
- [ ] Граф: общие точки объединяются, выделение по типу узла работает.

---

## 7) Дополнительные замечания (важное)

- Нельзя “чинить” проблему виртуальных станций фильтрацией в UI. Требование — **перестать создавать** их как сущности, чтобы не ломались расчёты и МНК.
- В Local/Network **разделяйте** понятия:
  - невязка (f) — диагностическая величина,
  - поправка (v) — добавка к наблюдению/Δh.
- По весам: лучше начать с `w = 1/L` (L в км), а дальше дать настройку.

---

_Конец документа._
