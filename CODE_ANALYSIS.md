# Предварительный анализ производительности

## Основные точки нагрузки
- **Построение строк хода** выполняется заново при каждом изменении данных, пересоздавая весь список `TraverseRow` без инкрементальных обновлений. Это включает многократные проходы по коллекциям и группировку по линиям. 【F:ViewModel/TraverseCalculationViewModel.cs†L538-L619】
- **Построитель хода** последовательно объединяет пары измерений, но при смене линии сбрасывает состояние и использует несколько вспомогательных флагов. Это линейный проход, однако на больших файлах подвержен лишним аллокациям из-за многократного создания временных `TraverseRow`. 【F:Service/TraverseBuilder.cs†L11-L140】
- **Загрузка файла** очищает коллекции и парсит весь файл, затем триггерит пересчёт без попытки переиспользовать существующие данные или минимизировать уведомления UI. 【F:ViewModel/DataViewModel.cs†L66-L94】

## Возможные оптимизации вычислений
1. **Кэшировать результат `TraverseBuilder.Build`** для текущего набора записей и сбрасывать только при фактическом изменении входных данных. Это уменьшит количество выделений и повторных группировок при переключении вкладок/классов расчёта, когда сами записи не меняются. Кэш можно хранить в `TraverseCalculationViewModel` и обновлять в обработчиках событий данных. 【F:ViewModel/TraverseCalculationViewModel.cs†L525-L619】
2. **Использовать инкрементальные обновления списков**: вместо `_rows.Clear()` и полной перестройки — сравнивать старые и новые группы станций и обновлять только изменённые элементы. Это сократит нагрузку на UI-тред и уменьшит количество уведомлений `INotifyCollectionChanged`. 【F:ViewModel/TraverseCalculationViewModel.cs†L538-L619】
3. **Упростить проход по группам** в `UpdateRows`: предварительно вычислять доступные якорные точки и отбрасывать необходимость повторного цикла `iteration` при отсутствии прогресса, заменив его топологической сортировкой по зависимостям высот или использованием очереди с готовыми якорями. Это уменьшит количество повторных проверок `GroupBy`-результата. 【F:ViewModel/TraverseCalculationViewModel.cs†L580-L619】
4. **Минимизировать аллокации в `TraverseBuilder`**: можно предварительно резервировать ёмкость списка `list` через `list.Capacity = recordsCount` (если известен) и переиспользовать один экземпляр `TraverseRow` для виртуальной станции вместо повторного создания при ошибочных последовательностях. Также стоит избегать лишних `ToList()` на больших коллекциях. 【F:Service/TraverseBuilder.cs†L13-L140】
5. **Ограничить число уведомлений во время загрузки**: в `LoadFromFile` уже есть батч-события, но после `Records.Clear()` и заполнения коллекции пересчёт вызывается несколько раз. Добавление механизма отложенного вычисления (например, флаг «грязности», который приводит к одному вызову `UpdateRows` после `EndBatchUpdate`) снимет лишние пересчёты. 【F:ViewModel/DataViewModel.cs†L66-L94】【F:ViewModel/TraverseCalculationViewModel.cs†L72-L84】
6. **Повторно использовать вычисленные высоты**: словари `availableAdjustedHeights` и `availableRawHeights` создаются заново при каждом вызове `UpdateRows`. Можно хранить их в полях и обновлять диффом, что уменьшит GC-нагрузку при частом переключении классов/методов расчёта. 【F:ViewModel/TraverseCalculationViewModel.cs†L565-L619】
7. **Анализировать горячие LINQ-выражения**: множественные `ToList()` и `GroupBy` в циклах увеличивают время выполнения. Частичный переход на итераторы или использование `ArrayPool` для временных коллекций позволит снизить аллокации, особенно при работе с большими журналами измерений. 【F:ViewModel/TraverseCalculationViewModel.cs†L558-L619】

## Наблюдения по архитектуре
- Поддержка батчевых обновлений уже присутствует, что упрощает внедрение ленивых пересчётов и кэширования. 【F:ViewModel/DataViewModel.cs†L66-L94】
- Все вычисления выполняются на UI-потоке в `UpdateRows`, что может блокировать интерфейс при больших файлах. Перенос тяжёлых частей (построение, группировка) в фоновый `Task` с последующим маршаллингом результатов в UI улучшит отзывчивость.

## Ближайшие шаги для ускорения
- Ввести кэш/флаг «грязности» для списка `TraverseRow` и словарей высот, обновляемый только при изменении исходных записей. 【F:ViewModel/TraverseCalculationViewModel.cs†L525-L619】
- Переписать внутренний цикл обработки групп на одно проходное решение с очередью готовых якорей, чтобы исключить лишние итерации. 【F:ViewModel/TraverseCalculationViewModel.cs†L580-L619】
- Добавить метрики времени (например, `Stopwatch` при отладке) вокруг `UpdateRows` и `TraverseBuilder.Build` для валидации улучшений и обнаружения узких мест.
